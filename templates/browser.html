<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neuronum: The E2E Web Engine</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/static/favicon.png" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/styles.css">
</head>
<body>

  <div class="main-grid-layout">
    <div class="bento-card cell-id-card">
      <h3><span id="cell-host"></span></h3>
      <a href="/#" id="disconnect-btn">Disconnect →</a>
      <a href="/#" id="delete-cell">Delete Cell →</a>
    </div>

    <div class="bento-card node-list-card">
      <h3>Nodes</h3>
       <a href="/#" id="update-nodes">Update Nodes →</a>
      <div class="search-container">
        <input type="text" id="node-search" placeholder="Search Nodes...">
      </div>
      <div id="node-list" class="node-list-container"></div>
    </div>

    <div class="bento-card node-screen-card" id="html-output">
      <div class="no-app-selected">
        <img src="/static/logo.png" alt="Neuronum Logo">
      </div>
      <div id="node-list-screen" class="node-list-container"></div>
    </div>

    <button id="fullscreen-toggle" class="fullscreen-button" title="Toggle Fullscreen">
      <i class="fas fa-expand"></i>
    </button>
  </div>

   <div id="customAlert" class="custom-alert">
      <div class="custom-alert-title">
      Alert Title
      </div>
      <div class="custom-alert-meta">
      Alert!
      and the collection and use of data as described in our
      </div>
      <button class="alert-close" id="alertClose">
        <span>close window<i class="fas fa-long-arrow-alt-right"></i></span>
      </button>
    </div>

  <div id="deleteAlert" class="custom-alert">
    <div class="custom-alert-content">
      <div class="custom-alert-title">Alert Title</div>
      <div class="custom-alert-meta">Alert!</div>
      <div class="custom-alert-actions">
        <button class="delete-confirm">
          <span>Confirm<i class="fas fa-check"></i></span>
        </button>
        <button class="delete-close">
          <span>Cancel<i class="fas fa-times"></i></span>
        </button>
      </div>
    </div>
  </div>


  <script>
    let allNodes = [];
    let host = null;
    let session = null;
    let nodeListContainer = null;

    async function fetchNodes() {
      const payload = { host, session };

      try {
        const response = await fetch("https://neuronum.net/browser/api/list_nodes", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify(payload)
        });

        const result = await response.json();

        if (!response.ok || !result.success) {
          const p = document.createElement("p");
          p.textContent = "No Public Nodes";
          if (nodeListContainer) nodeListContainer.appendChild(p);
          return;
        }

        if (result.Nodes.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No Public Nodes";
          if (nodeListContainer) nodeListContainer.appendChild(p);
          return;
        }

        allNodes = result.Nodes;
        renderNodes("");
      } catch (err) {
        const p = document.createElement("p");
        p.textContent = "Failed to fetch nodes. Network error.";
        if (nodeListContainer) nodeListContainer.appendChild(p);
      }
    }

    function renderNodes(searchTerm) {
      if (!nodeListContainer) return;

      nodeListContainer.innerHTML = '';

      const filteredNodes = allNodes.filter(node => {
        if (!node.config || !node.config.app_metadata || !node.config.public_key) {
          return false;
        }

        const nodePublicKey = node.config?.public_key.toLowerCase() || '';
        const nodeDescription = node.descr ? node.descr.toLowerCase() : '';
        const gatewayInfo = (node.config?.data_gateways || [])
          .flatMap(g => g.actions || [])
          .map(a => a.info ? a.info.toLowerCase() : '')
          .join(' ');
        const fullText = `${nodeDescription} ${gatewayInfo}`;
        return fullText.includes(searchTerm.toLowerCase());
      
      });

      if (filteredNodes.length === 0) {
        const p = document.createElement("p");
        p.textContent = "No Nodes found";
        nodeListContainer.appendChild(p);
        return;
      }

      filteredNodes.forEach(node => {
        if (node.config && node.config.app_metadata && node.config.public_key) {
          const nodeCard = document.createElement("div");
          nodeCard.className = "node-card";

          const title = document.createElement("h4");
          title.textContent = `${node.config.app_metadata.name}`;
          nodeCard.appendChild(title);

          const metadataDiv = document.createElement("div");
          metadataDiv.innerHTML = `
            <p><strong>Version:</strong> ${node.config.app_metadata.version}</p>
            <p><strong>Author:</strong> ${node.config.app_metadata.author}</p>
          `;
          nodeCard.appendChild(metadataDiv);

          if (node.config && node.config.legals) {
            const legalsDiv = document.createElement("div");
            legalsDiv.innerHTML = `
              <p><a href="${node.config.legals.terms}" target="_blank">Terms of Service</a></p>
              <p><a href="${node.config.legals.privacy_policy}" target="_blank">Privacy Policy</a></p>
            `;
            nodeCard.appendChild(legalsDiv);
          }

          const nodePublicKeyDiv = document.createElement("div");
          nodePublicKeyDiv.innerHTML = `
            <p class="public-key"><strong>Public Key:</strong> ${node.config.public_key}</p>
          `;
          nodeCard.appendChild(nodePublicKeyDiv);

          if (node.config && Array.isArray(node.config.data_gateways) && node.config.data_gateways.length > 0) {
            const gatewayList = document.createElement("ul");
            gatewayList.style.listStyle = "none";
            gatewayList.style.paddingLeft = "0";

            const actionsPresent = node.config.data_gateways.some(gateway =>
              gateway.node_id && gateway.node_id.endsWith("::node") && Array.isArray(gateway.actions) && gateway.actions.length > 0
            );

            if (actionsPresent) {
              const actionsTitle = document.createElement("h4");
              actionsTitle.style.marginTop = "25px";
              actionsTitle.textContent = "Actions";
              nodeCard.appendChild(actionsTitle);
            }

            node.config.data_gateways.forEach(gateway => {
              const gatewayID = gateway.node_id;

              if (gatewayID && gatewayID.endsWith("::node") && Array.isArray(gateway.actions) && gateway.actions.length > 0) {
                gateway.actions.forEach(actionItem => {
                  const li = document.createElement("li");
                  li.style.marginBottom = "10px";

                  const btn = document.createElement("button");
                  btn.className = "gateway-btn";
                  btn.textContent = actionItem.info;

                  btn.addEventListener("click", async () => {
                    const url = `https://neuronum.net/browser/api/activate_tx/${encodeURIComponent(gatewayID)}`;
                    const publicKeyJwk = localStorage.getItem('publicKey');
                    if (!publicKeyJwk) return;

                    const nodePublicKeyJwk = await convertPemToJwk(node.config.public_key);
                    console.log(node.config.public_key)
                    if (!nodePublicKeyJwk) {
                      showCustomAlert("Error", "Failed to convert node public key.");
                      return;
                    }

                    console.log(nodePublicKeyJwk);
                    const dataToEncrypt = { action: actionItem.action }; // This needs to be the payload to encrypt
                    const encryptedData = await encryptPayload(dataToEncrypt, nodePublicKeyJwk);
                    const payload = {
                        data: {
                            encrypted: encryptedData,
                            publicKey: publicKeyJwk
                        },
                        host: host,
                        session: session
                    };

                    console.log(payload);

                    try {
                      const res = await fetch(url, {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json"
                        },
                        body: JSON.stringify(payload)
                      });

                      if (res.ok) {
                        const data = await res.json();
                        if (data.success && data.response) {
                          try {
                            const decrypted = await decryptPayload(data.response);
                            handleTxResponse(decrypted, host, session);
                          } catch (decryptError) {
                            handleTxResponse(null, host, session);
                          }
                        } else {
                          handleTxResponse(null, host, session);
                        }
                      } else {
                        handleTxResponse(null, host, session);
                      }
                    } catch (err) {
                      handleTxResponse(null, host, session);
                    }
                  });

                  li.appendChild(btn);
                  gatewayList.appendChild(li);
                });
              }
            });

            nodeCard.appendChild(gatewayList);
          } else {
            const p = document.createElement("p");
            p.textContent = "(no gateways)";
            nodeCard.appendChild(p);
          }

          nodeListContainer.appendChild(nodeCard);
        }
      });
    }

    document.getElementById('update-nodes').addEventListener('click', async function (e) {
      e.preventDefault();
      await fetchNodes();
    });

    const disconnectBtn = document.getElementById("disconnect-btn");
    if (disconnectBtn) {
      disconnectBtn.addEventListener("click", (e) => {
        e.preventDefault();
        showCustomAlert('Cell Disconnected', 'disconnected from the Neuronum Network', () => {
          localStorage.clear();
          window.location.href = "/";
        });
      });
    }

    const deleteCellBtn = document.getElementById("delete-cell");
      if (deleteCellBtn) {
        deleteCellBtn.addEventListener("click", (e) => {
          e.preventDefault();
          showDeleteAlert('Delete Cell', 'Are you sure you want to delete this cell? This action is irreversible.', async () => {
            const session = localStorage.getItem('session');
            const host = localStorage.getItem('host');
            const guest = localStorage.getItem('guest');
        
            if (guest === "True") {
              localStorage.clear();
              window.location.href = '/';
              return;
            }
        
            try {
              const response = await fetch('https://neuronum.net/browser/api/delete_cell', {
                method: 'DELETE',
                headers: {
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  host: host,
                  session: session
                })
              });
        
              const result = await response.json();
        
              if (response.ok && result.status) {
                console.log('Cell deleted successfully:', result);
                localStorage.clear();
                window.location.href = '/';
              } else {
                console.error('Cell deletion failed:', result);
                showCustomAlert("Error", result.message || "Deletion failed. Please try again.");
              }
            } catch (err) {
              console.error("Error deleting cell:", err);
              showCustomAlert("Error", "An error occurred while deleting the cell.");
            }
          });
        });
      }

    function handleTxResponse(payload) {
      const htmlOutput = document.getElementById("html-output");
      htmlOutput.innerHTML = "";

      if (payload && payload.html) {
        const iframe = document.createElement("iframe");
        iframe.setAttribute("sandbox", "allow-popups");
        htmlOutput.appendChild(iframe);

        const blob = new Blob([payload.html], {
          type: "text/html"
        });
        const url = URL.createObjectURL(blob);

        iframe.src = url;

        iframe.onload = () => {
          URL.revokeObjectURL(url);
        };
      } else if (payload && payload.json) {
        const pre = document.createElement("pre");
        pre.textContent = payload.json;
        htmlOutput.appendChild(pre);
      } else {
        htmlOutput.innerHTML = `
          <div class="no-app-selected">
            <img src="/static/logo.png" alt="Neuronum Logo">
          </div>
        `;
      }
    }

    window.onload = function () {
      host = localStorage.getItem('host');
      session = localStorage.getItem('session');
      const cellHostSpan = document.getElementById('cell-host');
      nodeListContainer = document.getElementById('node-list');
      const nodeSearchInput = document.getElementById('node-search');

      if (host && cellHostSpan) {
        cellHostSpan.textContent = `${host}`;
      } else {
        cellHostSpan.textContent = 'cell not connected';
      }

      if (host && session) {
        fetchNodes();
      } else {
        console.error("Missing Host, Session for node list.");
      }

      if (nodeSearchInput) {
        nodeSearchInput.addEventListener('input', (event) => {
          const searchTerm = event.target.value.toLowerCase();
          renderNodes(searchTerm);
        });
      }
    };

    const fullscreenToggle = document.getElementById("fullscreen-toggle");
    const nodeScreenCard = document.getElementById("html-output");

    if (fullscreenToggle && nodeScreenCard) {
      fullscreenToggle.addEventListener("click", () => {
        const isFullscreen = nodeScreenCard.classList.toggle("fullscreen");
        const icon = fullscreenToggle.querySelector("i");

        if (isFullscreen) {
          icon.classList.remove("fa-expand");
          icon.classList.add("fa-compress");
        } else {
          icon.classList.remove("fa-compress");
          icon.classList.add("fa-expand");
        }
      });
    }

    window.addEventListener('message', async (event) => {
      const message = event.data;

      if (message?.type === 'iframe_request') {
        const {
          endpoint,
          data,
          nodePublicKey
        } = message;

        const host = localStorage.getItem('host');
        const session = localStorage.getItem('session');
        const publicKeyJwk = localStorage.getItem('publicKey');

        if (!host || !session || !publicKeyJwk || !nodePublicKey) {
          console.error("Missing required data for API request.");
          return;
        }

        try {
          const nodePublicKeyJwk = await convertPemToJwk(nodePublicKey);
          if (!nodePublicKeyJwk) {
            throw new Error("Failed to convert node public key.");
          }

          const encryptedData = await encryptPayload(data, nodePublicKeyJwk);

          const payload = {
            data: {
              encrypted: encryptedData,
              publicKey: publicKeyJwk
            },
            host: host,
            session: session
          };

          const response = await fetch(endpoint, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP error! Status: ${response.status}. Message: ${errorText}`);
          }

          const apiResponse = await response.json();

          if (apiResponse.success && apiResponse.response) {
            const decrypted = await decryptPayload(apiResponse.response);
            handleTxResponse(decrypted, host, session);

            const iframe = document.querySelector('iframe');
            if (iframe?.contentWindow) {
              iframe.contentWindow.postMessage({
                type: 'api_response',
                data: decrypted
              }, '*');
            }
          } else {
            handleTxResponse(null, host, session);

            const iframe = document.querySelector('iframe');
            if (iframe?.contentWindow) {
              iframe.contentWindow.postMessage({
                type: 'api_response_error',
                message: 'No valid response data found.'
              }, '*');
            }
          }
        } catch (error) {
          handleTxResponse(null, host, session);

          const iframe = document.querySelector('iframe');
          if (iframe?.contentWindow) {
            iframe.contentWindow.postMessage({
              type: 'api_response_error',
              message: `API request failed: ${error.message}`
            }, '*');
          }
        }
      }
    });

    function base64UrlToUint8Array(str) {
      const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
      const raw = window.atob(base64);
      const output = new Uint8Array(raw.length);
      for (let i = 0; i < raw.length; i++) {
        output[i] = raw.charCodeAt(i);
      }
      return output;
    }

    async function decryptPayload(encryptedPayload) {
      try {
        const privateKeyJwk = JSON.parse(localStorage.getItem('privateKey'));
        if (!privateKeyJwk) {
          throw new Error("Private key not found in localStorage.");
        }

        const privateKey = await window.crypto.subtle.importKey(
          "jwk",
          privateKeyJwk, {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true,
          ["deriveKey", "deriveBits"]
        );

        const ephemeralPublicKeyBytes = base64UrlToUint8Array(encryptedPayload.ephemeralPublicKey);
        const ephemeralPublicKey = await window.crypto.subtle.importKey(
          "raw",
          ephemeralPublicKeyBytes, {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true, []
        );

        const sharedSecret = await window.crypto.subtle.deriveBits({
          name: "ECDH",
          public: ephemeralPublicKey
        },
          privateKey,
          256
        );

        const aesKey = await window.crypto.subtle.deriveKey({
          name: "HKDF",
          salt: new Uint8Array(),
          info: new TextEncoder().encode("handshake data"),
          hash: "SHA-256",
        },
          await window.crypto.subtle.importKey("raw", sharedSecret, {
            name: "HKDF"
          }, false, ["deriveKey"]), {
            name: "AES-GCM",
            length: 256
          },
          true, ["decrypt"]
        );

        const nonce = base64UrlToUint8Array(encryptedPayload.nonce);
        const ciphertext = base64UrlToUint8Array(encryptedPayload.ciphertext);

        const decryptedBytes = await window.crypto.subtle.decrypt({
          name: "AES-GCM",
          iv: nonce,
        },
          aesKey,
          ciphertext
        );

        const decryptedString = new TextDecoder().decode(decryptedBytes);
        const finalResult = JSON.parse(decryptedString);

        return finalResult;
      } catch (error) {
        throw error;
      }
    }

    async function encryptPayload(payload, recipientPublicKeyJwk) {
      try {
        const recipientPublicKey = await window.crypto.subtle.importKey(
          "jwk",
          recipientPublicKeyJwk, {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true,
          []
        );

        const ephemeralKeyPair = await window.crypto.subtle.generateKey({
          name: "ECDH",
          namedCurve: "P-256"
        },
          true,
          ["deriveKey", "deriveBits"]
        );

        const sharedSecret = await window.crypto.subtle.deriveBits({
          name: "ECDH",
          public: recipientPublicKey
        },
          ephemeralKeyPair.privateKey,
          256
        );

        const aesKey = await window.crypto.subtle.deriveKey({
          name: "HKDF",
          salt: new Uint8Array(),
          info: new TextEncoder().encode("handshake data"),
          hash: "SHA-256",
        },
          await window.crypto.subtle.importKey("raw", sharedSecret, {
            name: "HKDF"
          }, false, ["deriveKey"]), {
            name: "AES-GCM",
            length: 256
          },
          true, ["encrypt"]
        );

        const nonce = window.crypto.getRandomValues(new Uint8Array(12));
        const encodedPayload = new TextEncoder().encode(JSON.stringify(payload));

        const encrypted = await window.crypto.subtle.encrypt({
          name: "AES-GCM",
          iv: nonce,
        },
          aesKey,
          encodedPayload
        );

        const ephemeralPublicKeyJwk = await window.crypto.subtle.exportKey("jwk", ephemeralKeyPair.publicKey);
        const ephemeralPublicKeyRaw = new Uint8Array(await window.crypto.subtle.exportKey("raw", ephemeralKeyPair.publicKey));

        return {
          ephemeralPublicKey: uint8ArrayToBase64Url(ephemeralPublicKeyRaw),
          nonce: uint8ArrayToBase64Url(nonce),
          ciphertext: uint8ArrayToBase64Url(new Uint8Array(encrypted)),
        };
      } catch (error) {
        throw error;
      }
    }

    function uint8ArrayToBase64Url(arr) {
      const base64 = btoa(String.fromCharCode.apply(null, arr));
      return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }

   async function convertPemToJwk(pem) {
      const pemContents = pem
        .replace("-----BEGIN PUBLIC KEY-----", "")
        .replace("-----END PUBLIC KEY-----", "")
        .replace("-----BEGINPUBLICKEY-----", "")
        .replace("-----ENDPUBLICKEY-----", "")
        .replace(/\s/g, "");

      const base64 = pemContents.replace(/-/g, '+').replace(/_/g, '/');

      const paddedBase64 = base64.padEnd(base64.length + (4 - base64.length % 4) % 4, '=');

      try {
        const binaryDer = _base64ToArrayBuffer(paddedBase64);

        const key = await window.crypto.subtle.importKey(
          "spki",
          binaryDer, {
            name: "ECDH",
            namedCurve: "P-256"
          },
          true,
          []
        );

        return await window.crypto.subtle.exportKey("jwk", key);
      } catch (e) {
        console.error("Error converting PEM to JWK:", e);
        return null;
      }
    }

    function _base64ToArrayBuffer(base64) {
      const binaryString = window.atob(base64);
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        bytes[i] = binaryString.charCodeAt(i);
      }
      return bytes.buffer;
    }

    function showCustomAlert(title, message, callback) {
        const alertBox = document.getElementById('customAlert');
        alertBox.querySelector('.custom-alert-title').innerText = title;
        alertBox.querySelector('.custom-alert-meta').innerText = message;
        alertBox.style.display = 'flex';

        setTimeout(() => {
          alertBox.style.opacity = 1;
        }, 10);
        
        document.getElementById('alertClose').addEventListener('click', () => {
          hideAlert('customAlert');
          if (callback) {
            callback();
          }
        }, { once: true });
    }

    function showDeleteAlert(title, message, onConfirm) {
      const alertBox = document.getElementById('deleteAlert');
      const confirmBtn = alertBox.querySelector('.delete-confirm');
      const cancelBtn = alertBox.querySelector('.delete-close');

      alertBox.querySelector('.custom-alert-title').innerText = title;
      alertBox.querySelector('.custom-alert-meta').innerText = message;
      alertBox.style.display = 'flex';

      setTimeout(() => {
        alertBox.style.opacity = 1;
      }, 10);

      const handleConfirm = () => {
        onConfirm();
        hideAlert('deleteAlert');
        cleanupListeners();
      };

      const handleCancel = () => {
        hideAlert('deleteAlert');
        cleanupListeners();
      };

      const cleanupListeners = () => {
        confirmBtn.removeEventListener('click', handleConfirm);
        cancelBtn.removeEventListener('click', handleCancel);
      };

      confirmBtn.addEventListener('click', handleConfirm);
      cancelBtn.addEventListener('click', handleCancel);
    }
    
    function hideAlert(alertBoxId) {
      const alertBox = document.getElementById(alertBoxId);
      if (alertBox) {
        alertBox.style.opacity = 0;
        setTimeout(() => {
          alertBox.style.display = 'none';
        }, 300);
      }
    }

    document.getElementById('alertClose').addEventListener('click', () => {
      hideAlert('customAlert');
    });

    document.getElementById('delete-cell').addEventListener('click', async function (e) {
      e.preventDefault();
      showDeleteAlert('Delete Cell', 'Are you sure you want to delete this cell? This action is irreversible.', async () => {
        const session = localStorage.getItem('session');
        const host = localStorage.getItem('host');
        const guest = localStorage.getItem('guest');

        if (guest === "True") {
          localStorage.clear();
          window.location.href = '/';
          return;
        }

        try {
          const response = await fetch('https://neuronum.net/browser/api/delete_cell', {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              host: host,
              session: session
            })
          });

          const result = await response.json();

          if (response.ok && result.status) {
            console.log('Cell deleted successfully:', result);
            localStorage.clear();
            window.location.href = '/';
          } else {
            console.error('Cell deletion failed:', result);
            showCustomAlert("Error", result.message || "Deletion failed. Please try again.");
          }
        } catch (err) {
          console.error("Error deleting cell:", err);
          showCustomAlert("Error", "An error occurred while deleting the cell.");
        }
      });
    });

  </script>
</body>
</html>