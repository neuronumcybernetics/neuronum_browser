<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neuronum: The Real-Time E2E Browser</title>

  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/static/favicon.png" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/static/desktop_design.css">
</head>

<body>

  <div id="custom-alert-modal" style="display: none; position: fixed; top: 40px; right: 40px; background-color: rgba(0, 0, 0, 0.7); z-index: 10000; justify-content: center; align-items: center;">
    <div style="background-color: #2a2a2a; color: #fff; padding: 20px; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
      <h4 style="margin-top: 0;">Alert</h4>
      <pre id="alert-content" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; background-color: #1e1e1e; padding: 10px; border-radius: 4px; border: 1px solid #333; max-height: 400px; overflow-y: auto;"></pre>
      <button id="close-alert-btn" style="margin-top: 20px; padding: 8px 16px; background-color: #01c07d; color: white; border: none; border-radius: 6px; cursor: pointer;">Close</button>
    </div>
  </div>

  <div class="main-grid-layout">
    <div class="bento-card cell-id-card">
      <h3><span id="cell-host"></span></h3>
      <a href="/#" id="disconnect-btn">Disconnect →</a>
      <a href="/neuronum_cellai" id="disconnect-btn">Update Nodes →</a>
    </div>

    <div class="bento-card node-list-card">
      <h3>Nodes</h3>
      <div class="search-container">
        <input type="text" id="node-search" placeholder="Search nodes...">
      </div>
      <div id="node-list" class="node-list-container"></div>
    </div>

    <div class="bento-card node-screen-card" id="html-output">
      <div class="no-app-selected">
        <img src="/static/logo.png" alt="Neuronum Logo">
      </div>
      <div id="node-list-screen" class="node-list-container"></div>
    </div>

    <div class="bento-card cell-stx-card">
      <h3>Notifications</h3>
      <div id="stx-data"></div>
    </div>
  </div>

  <button id="fullscreen-toggle" class="fullscreen-button" title="Toggle Fullscreen">
    <i class="fas fa-expand"></i>
  </button>

  <script>
    function handleTxResponse(payload, host, session) {
      const htmlOutput = document.getElementById("html-output");
      htmlOutput.innerHTML = "";

      if (payload && payload.html) {
        const iframe = document.createElement("iframe");
        htmlOutput.appendChild(iframe);
        const iframeDoc = iframe.contentWindow.document;
        iframeDoc.open();
        iframeDoc.write(payload.html);
        iframeDoc.close();
      } else if (payload && payload.json) {
        const pre = document.createElement("pre");
        pre.textContent = payload.json;
        htmlOutput.appendChild(pre);
      } else {
        htmlOutput.innerHTML = `
          <div class="no-app-selected">
            <img src="/static/logo.png" alt="Neuronum Logo">
          </div>
        `;
      }
    }

    window.onload = function () {
      const host = localStorage.getItem('host');
      const session = localStorage.getItem('session');
      const cellHostSpan = document.getElementById('cell-host');

      if (host && cellHostSpan) {
        cellHostSpan.textContent = `${host}`;
      } else {
        cellHostSpan.textContent = 'cell not connected';
      }

      const disconnectBtn = document.getElementById("disconnect-btn");
      if (disconnectBtn) {
        disconnectBtn.addEventListener("click", () => {
          localStorage.clear();
          window.location.href = "/";
        });
      }

      const nodeListContainer = document.getElementById('node-list');
      const nodeSearchInput = document.getElementById('node-search');
      let allNodes = [];

      if (host && session) {
        fetchNodes();
      } else {
        console.error("Missing Host, Session for node list.");
      }

      nodeSearchInput.addEventListener('input', (event) => {
        const searchTerm = event.target.value.toLowerCase();
        renderNodes(searchTerm);
      });

      async function fetchNodes() {
        const payload = { host, session };

        try {
          const response = await fetch("https://neuronum.net/browser/api/list_nodes", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload)
          });

          const result = await response.json();

          if (!response.ok || !result.success) {
            const p = document.createElement("p");
            p.textContent = "Failed to fetch nodes.";
            nodeListContainer.appendChild(p);
            return;
          }

          if (result.Nodes.length === 0) {
            const p = document.createElement("p");
            p.textContent = "No nodes available.";
            nodeListContainer.appendChild(p);
            return;
          }

          allNodes = result.Nodes;
          renderNodes("");
        } catch (err) {
          const p = document.createElement("p");
          p.textContent = "Failed to fetch nodes. Network error.";
          nodeListContainer.appendChild(p);
        }
      }

      function renderNodes(searchTerm) {
        nodeListContainer.innerHTML = '';

        const filteredNodes = allNodes.filter(node => {
          const nodeDescription = node.descr.toLowerCase();
          const gatewayInfo = (node.config?.data_gateways || [])
            .flatMap(g => g.actions || [])
            .map(a => a.info.toLowerCase())
            .join(' ');
          const fullText = `${nodeDescription} ${gatewayInfo}`;
          return fullText.includes(searchTerm);
        });

        if (filteredNodes.length === 0) {
          const p = document.createElement("p");
          p.textContent = "No nodes found matching your search.";
          nodeListContainer.appendChild(p);
          return;
        }

        filteredNodes.forEach(node => {
          const nodeCard = document.createElement("div");
          nodeCard.className = "node-card";

          if (node.config && node.config.app_metadata) {
            const title = document.createElement("h4");
            title.textContent = `${node.config.app_metadata.name}`;
            nodeCard.appendChild(title);

            const metadataDiv = document.createElement("div");
            metadataDiv.innerHTML = `
              <p><strong>Version:</strong> ${node.config.app_metadata.version}</p>
              <p><strong>Author:</strong> ${node.config.app_metadata.author}</p>
            `;
            nodeCard.appendChild(metadataDiv);
          }

          if (node.config && node.config.legals) {
            const legalsDiv = document.createElement("div");
            legalsDiv.innerHTML = `
              <p><a href="${node.config.legals.terms}" target="_blank">Terms of Service</a></p>
              <p><a href="${node.config.legals.privacy_policy}" target="_blank">Privacy Policy</a></p>
            `;
            nodeCard.appendChild(legalsDiv);
          }

          if (node.config && Array.isArray(node.config.data_gateways) && node.config.data_gateways.length > 0) {
            const gatewayList = document.createElement("ul");
            gatewayList.style.listStyle = "none";
            gatewayList.style.paddingLeft = "0";

            node.config.data_gateways.forEach(gateway => {
              const gatewayID = gateway.id;

              if (gatewayID.endsWith("::tx") && Array.isArray(gateway.actions) && gateway.actions.length > 0) {
                const gatewayTitle = document.createElement("h5");
                gatewayTitle.textContent = "Actions";
                gatewayTitle.style.marginTop = "20px";
                nodeCard.appendChild(gatewayTitle);

                gateway.actions.forEach(actionItem => {
                  const li = document.createElement("li");
                  li.style.marginBottom = "10px";

                  const btn = document.createElement("button");
                  btn.className = "gateway-btn";
                  btn.textContent = actionItem.info;

                  btn.addEventListener("click", async () => {
                    const url = `https://neuronum.net/api/activate/${encodeURIComponent(gatewayID)}`;
                    const publicKeyJwk = localStorage.getItem('publicKey');
                    if (!publicKeyJwk) return;

                    const payloadData = {
                      action: actionItem.action,
                      publicKey: JSON.parse(publicKeyJwk)
                    };

                    const payload = {
                      data: payloadData,
                      host: host,
                      session: session
                    };

                    try {
                      const res = await fetch(url, {
                        method: "POST",
                        headers: {
                          "Content-Type": "application/json"
                        },
                        body: JSON.stringify(payload)
                      });

                      if (res.ok) {
                        const data = await res.json();
                        showCustomAlert("Encrypted Data Received", JSON.stringify(data.response, null, 2));
                        if (data.success && data.response) {
                          try {
                            const decrypted = await decryptPayload(data.response);
                            showCustomAlert("Decrypted Data", JSON.stringify(decrypted, null, 2));
                            handleTxResponse(decrypted, host, session);
                          } catch (decryptError) {
                            showCustomAlert("Decryption Failed", decryptError.message);
                            handleTxResponse(null, host, session);
                          }
                        } else {
                          handleTxResponse(null, host, session);
                        }
                      } else {
                        showCustomAlert("Fetch Error", `Status: ${res.status}\nMessage: ${res.statusText}`);
                        handleTxResponse(null, host, session);
                      }
                    } catch (err) {
                      showCustomAlert("Fetch Error", err.message);
                      handleTxResponse(null, host, session);
                    }
                  });

                  li.appendChild(btn);
                  gatewayList.appendChild(li);
                });
              }
            });

            nodeCard.appendChild(gatewayList);
          } else {
            const p = document.createElement("p");
            p.textContent = "(no gateways)";
            nodeCard.appendChild(p);
          }

          nodeListContainer.appendChild(nodeCard);
        });
      }
    };

    const fullscreenToggle = document.getElementById("fullscreen-toggle");
    const nodeScreenCard = document.getElementById("html-output");

    if (fullscreenToggle && nodeScreenCard) {
      fullscreenToggle.addEventListener("click", () => {
        const isFullscreen = nodeScreenCard.classList.toggle("fullscreen");
        const icon = fullscreenToggle.querySelector("i");

        if (isFullscreen) {
          icon.classList.remove("fa-expand");
          icon.classList.add("fa-compress");
        } else {
          icon.classList.remove("fa-compress");
          icon.classList.add("fa-expand");
        }
      });
    }

window.addEventListener('message', async (event) => {
    if (event.origin !== 'http://127.0.0.1:55000') {
        console.error('Message received from an unauthorized origin:', event.origin);
        return;
    }

    const message = event.data;

    if (message?.type === 'iframe_request') {
        const { endpoint, data } = message;
        console.log("Received iframe_request from child. Endpoint:", endpoint, "Data:", data);

        const host = localStorage.getItem('host');
        const session = localStorage.getItem('session');
        const publicKeyJwk = localStorage.getItem('publicKey');

        if (!host || !session) {
            console.error("Missing host or session in localStorage. Cannot proceed.");
            showCustomAlert("Authentication Error", "Missing host or session data.");
            return;
        }

        if (!publicKeyJwk) {
            console.error("No public key found in localStorage!");
            showCustomAlert("Encryption Error", "No public key found in localStorage.");
            return;
        }

        try {
            const payload = {
                data: {
                    ...data, 
                    publicKey: JSON.parse(publicKeyJwk)
                },
                host: host,
                session: session
            };
            console.log("Sending API request with payload:", payload);

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! Status: ${response.status}. Message: ${errorText}`);
            }

            const apiResponse = await response.json();
            console.log('API call handled by parent:', apiResponse);

            if (apiResponse.success && apiResponse.response) {
                console.log("API response is successful. Proceeding with decryption.");
                const decrypted = await decryptPayload(apiResponse.response);
                console.log("Decrypted iframe response:", decrypted);
                
                handleTxResponse(decrypted, host, session);

                const iframe = document.querySelector('iframe');
                if (iframe?.contentWindow) {
                    iframe.contentWindow.postMessage({
                        type: 'api_response',
                        data: decrypted
                    }, '*');
                }
            } else {
                console.log("API response was not successful or did not contain a valid payload.");
                handleTxResponse(null, host, session);

                const iframe = document.querySelector('iframe');
                if (iframe?.contentWindow) {
                    iframe.contentWindow.postMessage({
                        type: 'api_response_error',
                        message: 'No valid response data found.'
                    }, '*');
                }
            }
        } catch (error) {
            console.error('API request failed in parent:', error);
            showCustomAlert("API Request Failed", `An error occurred: ${error.message}`);
            handleTxResponse(null, host, session);

            const iframe = document.querySelector('iframe');
            if (iframe?.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'api_response_error',
                    message: `API request failed: ${error.message}`
                }, '*');
            }
        }
    }
});

function showCustomAlert(title, message) {
    const modal = document.getElementById('custom-alert-modal');
    const content = document.getElementById('alert-content');
    const modalTitle = modal.querySelector('h4');

    modalTitle.textContent = title;
    content.textContent = message;
    modal.style.display = 'flex';
}

document.getElementById('close-alert-btn').addEventListener('click', () => {
    document.getElementById('custom-alert-modal').style.display = 'none';
});

function base64UrlToUint8Array(str) {
    const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
    const raw = window.atob(base64);
    const output = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) {
        output[i] = raw.charCodeAt(i);
    }
    return output;
}

async function decryptPayload(encryptedPayload) {
    try {
        console.log("Starting decryption process...");
        showCustomAlert("Decryption Status", "Starting decryption process...");

        const privateKeyJwk = JSON.parse(localStorage.getItem('privateKey'));
        if (!privateKeyJwk) {
            console.error("Private key not found in localStorage.");
            showCustomAlert("Decryption Failed", "Private key not found in localStorage.");
            throw new Error("Private key not found in localStorage.");
        }
        console.log("Private key loaded from localStorage.");
        showCustomAlert("Decryption Status", "Private key loaded from localStorage.");

        const privateKey = await window.crypto.subtle.importKey(
            "jwk",
            privateKeyJwk,
            { name: "ECDH", namedCurve: "P-256" },
            true,
            ["deriveKey", "deriveBits"]
        );
        console.log("Client's private key imported.");
        showCustomAlert("Decryption Status", "Client's private key imported.");

        const ephemeralPublicKeyBytes = base64UrlToUint8Array(encryptedPayload.ephemeralPublicKey);
        const ephemeralPublicKey = await window.crypto.subtle.importKey(
            "raw",
            ephemeralPublicKeyBytes,
            { name: "ECDH", namedCurve: "P-256" },
            true,
            []
        );
        console.log("Server's ephemeral public key imported.");
        showCustomAlert("Decryption Status", "Server's ephemeral public key imported.");

        const sharedSecret = await window.crypto.subtle.deriveBits(
            {
                name: "ECDH",
                public: ephemeralPublicKey
            },
            privateKey,
            256
        );
        console.log("Shared secret derived.");
        showCustomAlert("Decryption Status", "Shared secret derived.");

        const aesKey = await window.crypto.subtle.deriveKey(
            {
                name: "HKDF",
                salt: new Uint8Array(),
                info: new TextEncoder().encode("handshake data"),
                hash: "SHA-256",
            },
            await window.crypto.subtle.importKey("raw", sharedSecret, { name: "HKDF" }, false, ["deriveKey"]),
            { name: "AES-GCM", length: 256 },
            true,
            ["decrypt"]
        );
        console.log("AES-GCM key derived.");
        showCustomAlert("Decryption Status", "AES-GCM key derived.");

        const nonce = base64UrlToUint8Array(encryptedPayload.nonce);
        const ciphertext = base64UrlToUint8Array(encryptedPayload.ciphertext);

        const decryptedBytes = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: nonce,
            },
            aesKey,
            ciphertext
        );
        console.log("Ciphertext decrypted successfully.");
        showCustomAlert("Decryption Status", "Ciphertext decrypted successfully.");

        const decryptedString = new TextDecoder().decode(decryptedBytes);
        const finalResult = JSON.parse(decryptedString);
        console.log("Decryption complete. Final result:", finalResult);
        showCustomAlert("Decryption Success!", "Data has been successfully decrypted.");

        return finalResult;
    } catch (error) {
        console.error("Decryption failed:", error);
        showCustomAlert("Decryption Failed", `An error occurred: ${error.message}`);
        throw error;
    }
}

let stxSocket = null;
const stxDataElement = document.getElementById("stx-data");

function openStx() {
    const host = localStorage.getItem('host');
    const session = localStorage.getItem('session');

    if (!host || !session) return;

    if (stxSocket?.readyState === WebSocket.OPEN) return;

    const stxUrl = `wss://neuronum.net/api/sync/private`;

    console.log("Attempting to connect to:", stxUrl);

    try {
        stxSocket = new WebSocket(stxUrl);
    } catch (error) {
        console.error("Failed to create WebSocket:", error);
        return;
    }

    stxSocket.onopen = function () {
        console.log("WebSocket connection established.");

        const authPayload = {
            host: host,
            session: session
        };
        stxSocket.send(JSON.stringify(authPayload));
        console.log("Sent initial authentication payload.");
    };

    stxSocket.onmessage = function (event) {
        try {
            const notification = JSON.parse(event.data);

            if (notification.label === 'notification') {
                const card = document.createElement("div");
                card.className = "notification-card";

                const title = document.createElement("h4");
                title.className = "notification-title";
                title.textContent = notification.title || "Notification";
                card.appendChild(title);

                const message = document.createElement("p");
                message.className = "notification-message";
                message.textContent = notification.message || "No message content.";
                card.appendChild(message);

                const time = document.createElement("span");
                time.className = "notification-time";
                time.textContent = notification.time || new Date().toLocaleString();
                card.appendChild(time);

                stxDataElement.prepend(card);
            }
        } catch (e) {
            console.error("Failed to parse WebSocket message:", e);
        }
    };

    stxSocket.onclose = function (event) {
        console.log("WebSocket connection closed:", event);
        const reason = event.reason || "No reason given.";
        showCustomAlert("Connection Closed", `Stream STX WebSocket connection closed.\nCode: ${event.code}\nReason: ${reason}`);
        stxSocket = null;

        setTimeout(openStx, 5000);
    };

    stxSocket.onerror = function (error) {
        console.error("WebSocket error:", error);
        showCustomAlert("WebSocket Error", "An error occurred with the stream connection. See console for details.");
    };
}

window.addEventListener("load", () => {
    openStx();
});

  </script>
</body>
</html>