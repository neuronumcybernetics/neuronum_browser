<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="description" content="Neuronum is the real-time data engine for developers to build AI native apps and services in minutes using high-level Python">
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="robots" content="max-image-preview: none">
  <title>Neuronum: The Real-Time E2E Browser</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">
  <link rel="icon" type="image/x-icon" href="/static/favicon.png" />
  <link rel="stylesheet" href="/static/desktop_design.css">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
  <style>
    .bento-card {
      background: linear-gradient(145deg, rgba(255,255,255,0.02), rgba(0,0,0,0.2));
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 16px;
      padding: 24px;
      color: #eaeaea;
      font-family: 'Inter', sans-serif;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      transition: all 0.2s ease;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .bento-card:hover:not(.node-screen-card) {
      transform: scale(1.03);
      border-color: rgba(134, 134, 134, 0.12);
      background: rgba(255, 255, 255, 0.03);
    }


    .bento-card h3 {
      margin: 0 0 10px;
      font-size: 20px;
    }

    .bento-card p {
      font-size: 14px;
      opacity: 0.8;
    }

    .bento-card a {
      margin-top: 16px;
      display: inline-block;
      font-size: 13px;
      color: #a8c0ff;
      text-decoration: none;
    }

    .bento-card a:hover {
      text-decoration: underline;
    }

    /* New CSS for the main content container using CSS Grid */
    .main-grid-layout {
      position: fixed;
      top: 20px;
      left: 20px;
      right: 20px;
      bottom: 20px;
      display: grid;
      grid-template-columns: 300px 1fr; /* First column fixed, second fills space */
      grid-template-rows: auto 1fr; /* First row auto-sized, second fills rest of height */
      gap: 20px;
    }

    /* Grid item placement */
    .cell-id-card {
      grid-column: 1;
      grid-row: 1;
    }

     /* Grid item placement */
    .cell-stx-card {
      grid-column: 1;
      grid-row: 3;
      overflow-y: auto; /* Added to make the stx card scrollable */
    }

    .node-list-card {
      grid-column: 1;
      grid-row: 2;
      overflow-y: auto;
    }

    .node-screen-card {
      grid-column: 2;
      grid-row: 1 / span 3; /* This makes the card span both rows */
      overflow-y: auto;
      padding: 0;
    }

    /* Hides the scrollbar for the node list card */
    .node-list-card {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .node-list-card::-webkit-scrollbar {
      display: none;
    }

    .node-screen-card {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .node-screen-card::-webkit-scrollbar {
      display: none;
    }
    
    /* Hides the scrollbar for the stx card */
    .cell-stx-card {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .cell-stx-card::-webkit-scrollbar {
      display: none;
    }

    .node-card {
      background: rgba(255, 255, 255, 0.03);
      padding: 16px 24px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      margin-bottom: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }
    
    .node-card h4 {
      margin: 0 0 10px;
    }
    
    .gateway-btn {
      margin-left: 12px;
      padding: 5px 10px;
      font-size: 13px;
      cursor: pointer;
      background-color: #1c1c1c;
      color: #fff;
      border: 1px solid #333;
      border-radius: 6px;
    }
    
    .gateway-btn:hover {
      background-color: #2a2a2a;
    }

    .node-list-container {
      display: flex;
      flex-direction: column;
      gap: 18px;
    }

    /* CSS for the search bar */
    .search-container {
      margin-top: 10px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .search-container input[type="text"] {
      width: 100%;
      padding: 8px 12px;
      font-size: 14px;
      border-radius: 6px;
      background-color: #1c1c1c;
      color: #fff;
      border: 1px solid #333;
    }

    /* New CSS for the "no app selected" state */
    .no-app-selected {
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      height: 100%;
      opacity: 0.5;
    }

    .no-app-selected img {
      width: 65px;
      height: 65px;
      margin-bottom: -5px;
    }

    /* Style for the iframe container */
    #html-output iframe {
      width: 100%;
      height: 100%;
      border: none;
      background-color: transparent;
    }


/* Fullscreen layout override */
.node-screen-card.fullscreen {
  position: fixed !important;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  z-index: 10000;
  width: 100vw;
  height: 100vh;
  margin: 0;
  border-radius: 0;
  padding: 0;
  box-shadow: none;
  background-color: #111; /* optional: darken bg */
}

    .fullscreen-button {
      position: fixed;
      bottom: 40px;
      right: 40px;
      width: 50px;
      height: 50px;
      font-size: 18px;
      text-align: center;
      justify-content: center;
      align-items: center;
      display: flex;
      font-weight: 600;
      border: 1px solid rgb(22, 22, 22);
      background: none;
      color: rgb(255, 255, 255);
      font-family: 'Trebuchet MS';
      border-radius: 10px;
      backdrop-filter: blur(20px);
      transition: all 1000ms;
    }
     
    .fullscreen-button:hover {
      transform: scale(0.98);
      border: 1px solid rgb(255, 255, 255);
    }


.node-screen-card.fullscreen iframe {
  width: 100%;
  height: 100%;
}
/* New style for the stream output */
#stx-data {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 160px; /* New: Set a max height for the container */
    overflow-y: auto; /* New: Make it scrollable vertically */
}

  #stx-data {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    #stx-data::-webkit-scrollbar {
      display: none;
    }

/* New CSS for a single notification card */
.notification-card {
    background-color: #1a1a1a;
    border: 1px solid #333;
    border-radius: 8px;
    padding: 15px;
    word-wrap: break-word;
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    color: #eaeaea;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.notification-card:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
}

.notification-title {
    margin: 0 0 5px;
    font-size: 16px;
    font-weight: 600;
    color: #01c07d; /* Highlighted color for the title */
}

.notification-message {
    margin: 0 0 10px;
    opacity: 0.9;
}

.notification-time {
    font-size: 12px;
    opacity: 0.6;
    display: block;
    text-align: right;
}
  </style>
</head>
<body class="pageContainer">

  <div id="custom-alert-modal" style="display: none; position: fixed; top: 40px; right: 40px; background-color: rgba(0, 0, 0, 0.7); z-index: 10000; justify-content: center; align-items: center;">
  <div style="background-color: #2a2a2a; color: #fff; padding: 20px; border-radius: 8px; max-width: 500px; width: 90%; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);">
    <h4 style="margin-top: 0;">Alert</h4>
    <pre id="alert-content" style="white-space: pre-wrap; word-wrap: break-word; font-size: 14px; background-color: #1e1e1e; padding: 10px; border-radius: 4px; border: 1px solid #333; max-height: 400px; overflow-y: auto;"></pre>
    <button id="close-alert-btn" style="margin-top: 20px; padding: 8px 16px; background-color: #01c07d; color: white; border: none; border-radius: 6px; cursor: pointer;">Close</button>
  </div>
</div>

  <div class="main-grid-layout">
    <div class="bento-card cell-id-card">
      <h3><span id="cell-host"></span></h3> 
      <a href="/#" id="disconnect-btn">Disconnect →</a>
      <a href="/neuronum_cellai" id="disconnect-btn">Update Nodes →</a>
    </div>
    <div class="bento-card node-list-card">
      <h3>Nodes / Apps</h3>
      <div class="search-container">
          <input type="text" id="node-search" placeholder="Search nodes...">
      </div>
      <div id="node-list" class="node-list-container"></div>
    </div>
    <div class="bento-card node-screen-card" id="html-output">
      <div class="no-app-selected">
        <img src="/static/logo.png" alt="Neuronum Logo">
      </div>
      <div id="node-list-screen" class="node-list-container"></div>
    </div>
    <div class="bento-card cell-stx-card">
      <h3>Notifications</h3>
      <div id="stx-data"></div>
    </div>
  </div>

    <button id="fullscreen-toggle" class="fullscreen-button" title="Toggle Fullscreen">
        <i class="fas fa-expand"></i>
    </button>

  <script>
    function handleTxResponse(payload, host, session) {
  const htmlOutput = document.getElementById("html-output");
  htmlOutput.innerHTML = "";

  if (payload && payload.html) {
    // Escape single quotes in host and session variables
    const escapedHost = host.replace(/'/g, "\\'");
    const escapedSession = session.replace(/'/g, "\\'");

    // Create the script tag content to inject with escaped values
    // Create an iframe to display the HTML content
  const iframe = document.createElement("iframe");
  htmlOutput.appendChild(iframe);

  // Write the HTML content to the iframe's document
  const iframeDoc = iframe.contentWindow.document;
  iframeDoc.open();
  iframeDoc.write(payload.html);
  iframeDoc.close();

  } else if (payload && payload.json) {
    // Display JSON as a pre-formatted block
    const pre = document.createElement("pre");
    pre.textContent = payload.json;
    htmlOutput.appendChild(pre);
  } else {
    htmlOutput.innerHTML = `
      <div class="no-app-selected">
        <img src="/static/logo.png" alt="Neuronum Logo">
      </div>
    `;
  }
}

    window.onload = function () {
      const host = localStorage.getItem('host');
      const session = localStorage.getItem('session');


      const cellHostSpan = document.getElementById('cell-host');
      if (host && cellHostSpan) {
        cellHostSpan.textContent = `${host}`;
      } else {
        cellHostSpan.textContent = 'cell not connected';
      }

      const disconnectBtn = document.getElementById("disconnect-btn");
      if (disconnectBtn) {
        disconnectBtn.addEventListener("click", () => {
          localStorage.clear();
          window.location.href = "/";
        });
      }

      const nodeListContainer = document.getElementById('node-list');
      const nodeSearchInput = document.getElementById('node-search');
      let allNodes = [];

      if (host && session) {
        fetchNodes();
      } else {
        console.error("Missing Host, Session for node list.");
      }

      nodeSearchInput.addEventListener('input', (event) => {
        const searchTerm = event.target.value.toLowerCase();
        renderNodes(searchTerm);
      });

      async function fetchNodes() {
        const payload = { host, session };

        try {
          const response = await fetch("https://neuronum.net/browser/api/list_nodes", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify(payload)
          });

          const result = await response.json();

          if (!response.ok || !result.success) {
            console.error("Failed to fetch nodes: " + (result.message || response.statusText));
            const p = document.createElement("p");
            p.textContent = "Failed to fetch nodes.";
            nodeListContainer.appendChild(p);
            return;
          }

          if (result.Nodes.length === 0) {
            const p = document.createElement("p");
            p.textContent = "No nodes available.";
            nodeListContainer.appendChild(p);
            return;
          }
          
          allNodes = result.Nodes;
          renderNodes("");
        } catch (err) {
          console.error("Fetch failed: " + err.message);
          const p = document.createElement("p");
          p.textContent = "Failed to fetch nodes. Network error.";
          nodeListContainer.appendChild(p);
        }
      }
      
     function renderNodes(searchTerm) {
    nodeListContainer.innerHTML = '';

    const filteredNodes = allNodes.filter(node => {
        const nodeDescription = node.descr.toLowerCase();
        // Updated to search through the new nested 'actions' array
        const gatewayInfo = (node.config?.data_gateways || [])
            .flatMap(g => g.actions || [])
            .map(a => a.info.toLowerCase())
            .join(' ');
        const fullText = `${nodeDescription} ${gatewayInfo}`;
        return fullText.includes(searchTerm);
    });

    if (filteredNodes.length === 0) {
        const p = document.createElement("p");
        p.textContent = "No nodes found matching your search.";
        nodeListContainer.appendChild(p);
        return;
    }

    filteredNodes.forEach(node => {
        const nodeCard = document.createElement("div");
        nodeCard.className = "node-card";

        // --- App Metadata ---
        if (node.config && node.config.app_metadata) {
            const title = document.createElement("h4");
            title.textContent = `${node.config.app_metadata.name}`;
            nodeCard.appendChild(title);
            const metadataDiv = document.createElement("div");
            metadataDiv.innerHTML = `
                <p><strong>Version:</strong> ${node.config.app_metadata.version}</p>
                <p><strong>Author:</strong> ${node.config.app_metadata.author}</p>
            `;
            nodeCard.appendChild(metadataDiv);
        }

        // --- Legals ---
        if (node.config && node.config.legals) {
            const legalsDiv = document.createElement("div");
            legalsDiv.innerHTML = `
                <p><a href="${node.config.legals.terms}" target="_blank">Terms of Service</a></p>
                <p><a href="${node.config.legals.privacy_policy}" target="_blank">Privacy Policy</a></p>
            `;
            nodeCard.appendChild(legalsDiv);
        }

        // --- Data Gateways with Actions ---
        if (node.config && Array.isArray(node.config.data_gateways) && node.config.data_gateways.length > 0) {
            const gatewayList = document.createElement("ul");
            gatewayList.style.listStyle = "none";
            gatewayList.style.paddingLeft = "0";

            // Loop through each gateway object
            node.config.data_gateways.forEach(gateway => {
                const gatewayID = gateway.id;

                // Check for the "::tx" suffix and if there are actions
                if (gatewayID.endsWith("::tx") && Array.isArray(gateway.actions) && gateway.actions.length > 0) {
                    const gatewayTitle = document.createElement("h5");
                    gatewayTitle.textContent = "Actions";
                    gatewayTitle.style.marginTop = "20px";
                    nodeCard.appendChild(gatewayTitle);

                    // Loop through the actions array for each gateway
                    gateway.actions.forEach(actionItem => {
                        const li = document.createElement("li");
                        li.style.marginBottom = "10px";

                        const btn = document.createElement("button");
                        btn.className = "gateway-btn";
                        btn.textContent = actionItem.info;

                        btn.addEventListener("click", async () => {
                            const url = `https://neuronum.net/api/activate/${encodeURIComponent(gatewayID)}`;
                            console.log(`Sending POST request to ${url}...`);

                            const publicKeyJwk = localStorage.getItem('publicKey');
                            if (!publicKeyJwk) {
                                console.error("No public key found in localStorage!");
                                return;
                            }

                            // The payload is now dynamically created from the action object
                            const payloadData = {
                                "action": actionItem.action,
                                "publicKey": JSON.parse(publicKeyJwk)
                            };

                            const payload = {
                                data: payloadData,
                                host: host,
                                session: session
                            };

                            try {
                                const res = await fetch(url, {
                                    method: "POST",
                                    headers: {
                                        "Content-Type": "application/json"
                                    },
                                    body: JSON.stringify(payload)
                                });

                                if (res.ok) {
                                    const data = await res.json();
                                    console.log(`Response for ${gatewayID}:`, data);
                                    showCustomAlert("Encrypted Data Received", JSON.stringify(data.response, null, 2));
                                    if (data.success && data.response) {
                                        try {
                                            const decrypted = await decryptPayload(data.response);
                                            console.log("Decrypted response:", decrypted);
                                            showCustomAlert("Decrypted Data", JSON.stringify(decrypted, null, 2));
                                            handleTxResponse(decrypted, host, session);
                                        } catch (decryptError) {
                                            console.error("Decryption failed:", decryptError);
                                            showCustomAlert("Decryption Failed", decryptError.message);
                                            handleTxResponse(null, host, session);
                                        }
                                    } else {
                                        console.log("No valid response data found.");
                                        handleTxResponse(null, host, session);
                                    }
                                } else {
                                    console.error(`Error ${res.status}: ${res.statusText}`);
                                    showCustomAlert("Fetch Error", `Status: ${res.status}\nMessage: ${res.statusText}`);
                                    handleTxResponse(null, host, session);
                                }
                            } catch (err) {
                                console.error(`Fetch error: ${err.message}`);
                                showCustomAlert("Fetch Error", err.message);
                                handleTxResponse(null, host, session);
                            }
                        });
                        li.appendChild(btn);
                        gatewayList.appendChild(li);
                    });
                }
            });
            nodeCard.appendChild(gatewayList);
        } else {
            const p = document.createElement("p");
            p.textContent = "(no gateways)";
            nodeCard.appendChild(p);
        }
        nodeListContainer.appendChild(nodeCard);
    });
}
    };

    // Fullscreen toggle
const fullscreenToggle = document.getElementById("fullscreen-toggle");
const nodeScreenCard = document.getElementById("html-output");

if (fullscreenToggle && nodeScreenCard) {
  fullscreenToggle.addEventListener("click", () => {
    const isFullscreen = nodeScreenCard.classList.toggle("fullscreen");
    const icon = fullscreenToggle.querySelector("i");

    if (isFullscreen) {
      icon.classList.remove("fa-expand");
      icon.classList.add("fa-compress");
    } else {
      icon.classList.remove("fa-compress");
      icon.classList.add("fa-expand");
    }
  });
}

window.addEventListener('message', async (event) => {
    // ⚠️ Security check: Always verify the origin
    if (event.origin !== 'http://127.0.0.1:55000') {
        console.error('Message received from an unauthorized origin:', event.origin);
        return;
    }

    const message = event.data;

    if (message && message.type === 'iframe_request') {
        const { endpoint, data } = message;
        console.log("Received iframe_request from child. Endpoint:", endpoint, "Data:", data);

        const host = localStorage.getItem('host');
        const session = localStorage.getItem('session');
        const publicKeyJwk = localStorage.getItem('publicKey');

        if (!host || !session) {
            console.error("Missing host or session in localStorage. Cannot proceed.");
            showCustomAlert("Authentication Error", "Missing host or session data.");
            return;
        }

        if (!publicKeyJwk) {
          console.error("No public key found in localStorage!");
          showCustomAlert("Encryption Error", "No public key found in localStorage.");
          return;
        }

        try {
            // Construct the payload to be sent to the API
            const payload = {
                data: {
                    ...data, 
                    publicKey: JSON.parse(publicKeyJwk)
                },
                host: host,
                session: session
            };
            console.log("Sending API request with payload:", payload);

            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`HTTP error! Status: ${response.status}. Message: ${errorText}`);
            }

            const apiResponse = await response.json();
            console.log('API call handled by parent:', apiResponse);

            if (apiResponse.success && apiResponse.response) {
                console.log("API response is successful. Proceeding with decryption.");
                const decrypted = await decryptPayload(apiResponse.response);
                console.log("Decrypted iframe response:", decrypted);
                
                handleTxResponse(decrypted, host, session);

                const iframe = document.querySelector('iframe');
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        type: 'api_response',
                        data: decrypted
                    }, '*');
                }
            } else {
                console.log("API response was not successful or did not contain a valid payload.");
                handleTxResponse(null, host, session);

                const iframe = document.querySelector('iframe');
                if (iframe && iframe.contentWindow) {
                    iframe.contentWindow.postMessage({
                        type: 'api_response_error',
                        message: 'No valid response data found.'
                    }, '*');
                }
            }
        } catch (error) {
            console.error('API request failed in parent:', error);
            showCustomAlert("API Request Failed", `An error occurred: ${error.message}`);
            handleTxResponse(null, host, session);

            const iframe = document.querySelector('iframe');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: 'api_response_error',
                    message: `API request failed: ${error.message}`
                }, '*');
            }
        }
    }
});



// Function to show the custom alert modal
function showCustomAlert(title, message) {
  const modal = document.getElementById('custom-alert-modal');
  const content = document.getElementById('alert-content');
  const modalTitle = modal.querySelector('h4');

  modalTitle.textContent = title;
  content.textContent = message;
  modal.style.display = 'flex';
}

// Add event listener to the close button
document.getElementById('close-alert-btn').addEventListener('click', () => {
  document.getElementById('custom-alert-modal').style.display = 'none';
});

// Function to decode a base64 string to an ArrayBuffer
function base64UrlToUint8Array(str) {
  const base64 = str.replace(/-/g, '+').replace(/_/g, '/');
  const raw = window.atob(base64);
  const output = new Uint8Array(raw.length);
  for (let i = 0; i < raw.length; i++) {
    output[i] = raw.charCodeAt(i);
  }
  return output;
}

// Function to decrypt the payload received from the server
async function decryptPayload(encryptedPayload) {
  try {
    console.log("Starting decryption process...");
    showCustomAlert("Decryption Status", "Starting decryption process...");

    // 1. Get the private key from localStorage
    const privateKeyJwk = JSON.parse(localStorage.getItem('privateKey'));
    if (!privateKeyJwk) {
      console.error("Private key not found in localStorage.");
      showCustomAlert("Decryption Failed", "Private key not found in localStorage.");
      throw new Error("Private key not found in localStorage.");
    }
    console.log("Private key loaded from localStorage.");
    showCustomAlert("Decryption Status", "Private key loaded from localStorage.");

    // 2. Import your private key
    const privateKey = await window.crypto.subtle.importKey(
      "jwk",
      privateKeyJwk,
      { name: "ECDH", namedCurve: "P-256" },
      true,
      ["deriveKey", "deriveBits"]
    );
    console.log("Client's private key imported.");
    showCustomAlert("Decryption Status", "Client's private key imported.");

    // 3. Import the ephemeral public key from the server's response
    // CORRECTED: Use "raw" format instead of "spki"
    const ephemeralPublicKeyBytes = base64UrlToUint8Array(encryptedPayload.ephemeralPublicKey);
    const ephemeralPublicKey = await window.crypto.subtle.importKey(
      "raw", // Use "raw" for the uncompressed X9.62 point
      ephemeralPublicKeyBytes,
      { name: "ECDH", namedCurve: "P-256" },
      true,
      []
    );
    console.log("Server's ephemeral public key imported.");
    showCustomAlert("Decryption Status", "Server's ephemeral public key imported.");

    // 4. Derive the shared secret using ECDH
    const sharedSecret = await window.crypto.subtle.deriveBits(
      {
        name: "ECDH",
        public: ephemeralPublicKey
      },
      privateKey,
      256
    );
    console.log("Shared secret derived.");
    showCustomAlert("Decryption Status", "Shared secret derived.");

    // 5. Derive the AES-GCM key from the shared secret
    const aesKey = await window.crypto.subtle.deriveKey(
      {
        name: "HKDF",
        salt: new Uint8Array(),
        info: new TextEncoder().encode("handshake data"),
        hash: "SHA-256",
      },
      await window.crypto.subtle.importKey("raw", sharedSecret, { name: "HKDF" }, false, ["deriveKey"]),
      { name: "AES-GCM", length: 256 },
      true,
      ["decrypt"]
    );
    console.log("AES-GCM key derived.");
    showCustomAlert("Decryption Status", "AES-GCM key derived.");

    // 6. Decrypt the ciphertext
    const nonce = base64UrlToUint8Array(encryptedPayload.nonce);
    const ciphertext = base64UrlToUint8Array(encryptedPayload.ciphertext);

    const decryptedBytes = await window.crypto.subtle.decrypt(
      {
        name: "AES-GCM",
        iv: nonce,
      },
      aesKey,
      ciphertext
    );
    console.log("Ciphertext decrypted successfully.");
    showCustomAlert("Decryption Status", "Ciphertext decrypted successfully.");

    // 7. Decode the decrypted bytes and parse as JSON
    const decryptedString = new TextDecoder().decode(decryptedBytes);
    const finalResult = JSON.parse(decryptedString);
    console.log("Decryption complete. Final result:", finalResult);
    showCustomAlert("Decryption Success!", "Data has been successfully decrypted.");

    return finalResult;

  } catch (error) {
    console.error("Decryption failed:", error);
    showCustomAlert("Decryption Failed", `An error occurred: ${error.message}`);
    throw error;
  }
}

// A variable to hold the WebSocket connection
let stxSocket = null;

// Get the HTML element
const stxDataElement = document.getElementById("stx-data");

// Function to handle opening the WebSocket connection
function openStx() {
  const host = localStorage.getItem('host');
  const session = localStorage.getItem('session');

  if (!host || !session) return;

  if (stxSocket && stxSocket.readyState === WebSocket.OPEN) return;

  const stxId = host.replace('::cell', '::stx');
  const stxUrl = `wss://neuronum.net/api/sync/${stxId}`;

  console.log("Attempting to connect to:", stxUrl);

  try {
    stxSocket = new WebSocket(stxUrl);
  } catch (error) {
    console.error("Failed to create WebSocket:", error);
    return;
  }

  stxSocket.onopen = function () {
    console.log("WebSocket connection established.");

    const authPayload = {
      host: host,
      session: session
    };
    stxSocket.send(JSON.stringify(authPayload));
    console.log("Sent initial authentication payload.");
  };

  stxSocket.onmessage = function (event) {
    try {
      const notification = JSON.parse(event.data);

      // Only process messages with label "notification"
      if (notification.label === 'notification') {
        // Create a new notification card element
        const card = document.createElement("div");
        card.className = "notification-card";

        const title = document.createElement("h4");
        title.className = "notification-title";
        title.textContent = notification.title || "Notification";
        card.appendChild(title);

        const message = document.createElement("p");
        message.className = "notification-message";
        message.textContent = notification.message || "No message content.";
        card.appendChild(message);

        const time = document.createElement("span");
        time.className = "notification-time";
        time.textContent = notification.time || new Date().toLocaleString();
        card.appendChild(time);

        stxDataElement.prepend(card);
      }

      // If not a "notification", do nothing
    } catch (e) {
      console.error("Failed to parse WebSocket message:", e);
    }
  };

  stxSocket.onclose = function (event) {
    console.log("WebSocket connection closed:", event);
    const reason = event.reason || "No reason given.";
    showCustomAlert("Connection Closed", `Stream STX WebSocket connection closed.\nCode: ${event.code}\nReason: ${reason}`);
    stxSocket = null;

    // Automatically attempt to reconnect after a delay
    setTimeout(openStx, 5000);
  };

  stxSocket.onerror = function (error) {
    console.error("WebSocket error:", error);
    showCustomAlert("WebSocket Error", "An error occurred with the stream connection. See console for details.");
  };
}


// Call openStx on page load to establish the connection immediately
window.addEventListener("load", () => {
  openStx();
});

  </script>
</body>
</html>